# F 代码规范
## 基本原则
- 遵循C++23标准
- 少“造轮子”多复用
- 高内聚低耦合


## 代码布局
- 使用4个空格进行缩进，不使用Tab字符
- 每行代码不超过80个字符
- 开始新的逻辑块时添加空白行以提高可读性
- namespace 不缩进，switch-case不缩进，extern "C" 不缩进

## 文件结构
- 优先使用 import 而非头文件引入依赖
- 如果有必要使用include，必须放置于全局模块片段中并按照首字母排序
```c++
module;
#include <xxx.h>
// 全局模块片段
export module xxxx;
```
- 实体声明于ixx，实现于cpp
- 按照声明的顺序实现


## 命名规范
- 变量名，函数名，函数形参，模板形参，类名和类型成员使用蛇形命名（例如：my_variable）
    - protected和private成员增加下划线前缀（如_my_member）
- 命名除常见缩写（如id，uuid，json）等必须写明全称
- 命名空间蛇形命名, 优先使用namespace a::b而不是内嵌另一个命名空间
- 禁止name shadow（内外层实体重名导致的外层实体无法访问）
- 函数采用后置类型声明


## 初始化
- 优先使用大括号初始化，除非存在歧义（例如，vector<int>(5)被解释为初始5个int，而vector<int>{5}被解释为初始一个int 5）
- local var优先声明方式为auto x = T{}或auto&& x = foo()
- 局部变量定义 *必须* 使用auto


## 注释
- 对于复杂的算法或逻辑，应在其实现之前提供注释说明


## 内存管理
- 对于STL的容器，必须采用f模块中的变体
- 对于有所有权的动态对象，优先使用f::make_unique创建，f::unique_ptr管理
- 对于没有所有权的不可变引用，采用左值引用管理
- 对于没有所有权的可变引用，采用指针管理


## 封装
- 类型名称必须为蛇形命名
- 如果类型大部分字段必须可读写，则使用struct
- 如果类型字段大部分字段不可读写，则使用class
- 类中声明顺序为：
```c++
class my_class{
    friend class clazz1;
    friend auto foo1() noexcept -> void;
public
    auto foo() noexcept -> void;
    auto bar() noexcept -> int&;

    auto operator [](auto&& self, auto i) noexcept -> int&;

    my_class() noexcept=default;
    my_class(const my_class&) noexcept=default;
    my_class(my_class&&) noexcept=default;
    explicit
    my_class(int) noexcept;
    ~my_class() noexcept=default;

protected:
    auto foo2() noexcept -> void;
    auto bar2() noexcept -> void;

    int
        _member1;

private:
    f::string
        _member2;
};
```
- struct 的成员名称需要在类型下一行并左对齐
- class 的成员名称需要在类型下一行并缩进
- 其中函数顺序按照重要程度排序
- 如果确实有必要设置getter/setter，请遵循c++习惯的函数签名,如下
```c++
class x{
public:
    auto member() const -> int;
    auto member(int neo_member) -> int;
    
   
private:
    int
        _member;
};
```
- 必须严格遵循RAII，禁止任何形式的二次初始化，初始化不成功就抛异常（因为假定构造无异常就是成功了）


## 错误处理
- 使用f::exception来报告无法处理的错误，确保资源被正确释放（f::exception支持格式字符串）
- 对于频繁的可预期错误（例如可空的对象不存在），改用std::optional或者std::expected
- 提供清晰的错误消息，便于调试


## 字面量
- 结构体字面量可以使用指派初始化，但依照C++规定必须按照成员顺序指派，如
```c++
struct x {
    int a;
    float b;
    const char* c;
};

auto literal_x = X{
    .a=1, 
    .b=2.5f,
    .c="hello"
};
```


## 测试
- 为关键功能编写单元测试
- 确保所有公开接口都有对应的测试案例
- 定期运行测试套件，保证新改动不会破坏现有功能


## 字符串处理
- 必须使用f::string处理字符串，使用f::cvt进行宽窄字符串转换
  - f::cvt第一个参数是一个(w)string_view，第二个参数是个(w)string的引用
- 只读字符串传递给老式C字符串API时，如果该参数是只读的， 则允许且仅在此允许使用const_cast移除const属性


## 运行时多态
- 运行时多态会损失性能，谨慎使用；但如果会带来可读性提升，那么要敢于舍弃部分性能换取可读性
- 运行时类型的判断应当使用 typeid 运算


## 容器视图
- 对于连续元素的只读视图，采用std::span<const T>
- 对于连续元素的可写视图，采用std::span<T>
- 对于字符串视图，采用std::string_view


