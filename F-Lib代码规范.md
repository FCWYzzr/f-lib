# F-Lib代码规范

# 一、基本原则

- **标准遵循**：严格遵循C++23标准进行代码编写，充分利用现代C++特性提升代码质量与开发效率，禁止使用过时的语法与特性。

- **复用优先**：秉持“少造轮子多复用”的理念，优先使用成熟的库组件（如F模块提供的工具类、容器等）及标准库特性，避免重复开发功能相似的代码，降低维护成本。

- **设计原则**：遵循“高内聚低耦合”的软件设计思想，模块内部功能集中，模块间依赖清晰且松散，便于代码的扩展、测试与维护。

# 二、代码布局

- **缩进规则**：统一使用4个空格进行缩进，禁止使用Tab字符，确保在不同编辑器环境下代码格式一致。

- **行宽限制**：每行代码字符数不超过80个，超长代码需合理换行拆分（如运算符后换行、参数列表分多行），提升代码可读性。

- **空白行使用**：开始新的逻辑块（如函数、循环体、条件分支的独立逻辑段）时，添加空白行分隔，使代码层次结构更清晰。

- **特殊块缩进**：namespace内部代码不缩进，switch-case结构中case标签不缩进，extern "C"包裹的代码块不缩进，保持代码简洁紧凑。

# 三、文件结构

- **依赖引入优先**：优先使用C++23模块特性的import语句引入依赖，替代传统头文件包含方式。

- **include使用规范**：若因兼容性等原因必须使用#include，需将其放置于全局模块片段中，且包含的头文件按首字母升序排序，示例如下：
        `module;
#include <algorithm.h>
#include <vector.h>
// 全局模块片段结束
export module sample_module;
`

- **文件分工**：模块实体（如类、函数的声明）统一放置于.ixx后缀的模块接口文件中，具体实现代码则存放于.cpp文件中，实现文件需与接口文件保持对应。

- **实现顺序**：cpp文件中函数、类成员的实现顺序，需与ixx文件中对应的声明顺序一致，便于代码的查找与关联维护。

# 四、工程文件布局（CMake）

- **目录结构规范**：采用“根目录-模块”的分层架构，每个模块独立包含源码与构建配置，便于模块复用与团队协作，标准目录结构如下：
`root/                  # 项目根目录
├── cmake/             # CMake辅助脚本目录
│   └── utils.cmake    # CMake脚本
├── doc/               # 文档目录
├── modules/           # 核心模块目录，存放所有业务/功能模块
│   ├── module_a/      # 模块A目录（独立功能单元）
│   │   ├── src/       # 模块A源码目录
│   │   │   ├── xxx.ixx # 模块A接口文件（C++23模块）
│   │   │   └── xxx.cpp # 模块A实现文件
│   │   └── CMakeLists.txt # 模块A构建配置文件
│   └── module_b/      # 模块B目录（独立功能单元）
│       ├── src/       # 模块B源码目录
│       │   ├── xxx.ixx # 模块B接口文件（C++23模块）
│       │   └── xxx.cpp # 模块B实现文件
│       └── CMakeLists.txt # 模块B构建配置文件
├── CMakeLists.txt     # 项目根目录构建文件（统筹模块依赖与构建流程）
├── README.md          # 项目说明文档（功能介绍、构建指南等）
` `└── LICENSE            # 项目许可协议文件`

- **关键目录/文件说明**：
        `cmake/`：仅存放通用CMake脚本，如编译选项配置、自定义查找模块、工具函数封装等，避免各模块重复配置；脚本命名采用蛇形命名，确保可读性。

- `doc/`：集中存放项目文档，如接口说明、设计文档、使用手册等，便于统一管理与查阅。

- `modules/`：每个子目录对应一个独立模块，模块内必须包含`src/`目录（存放源码）和`CMakeLists.txt`（模块专属构建配置），模块间通过CMake的`target_link_libraries`建立依赖，禁止跨模块直接引用源码文件。

- `README.md`：需包含项目核心功能、C++23环境依赖、CMake构建步骤（如编译命令、参数说明）、模块说明等关键信息，便于开发者快速上手。

- `LICENSE`：存放项目许可协议，明确代码使用权限与约束。

- **CMake配置核心原则**：根目录CMake仅做全局配置（如标准版本、子目录引入），模块CMake专注自身目标构建，通过“目标依赖”替代“路径依赖”，确保构建逻辑清晰可维护。

- **构建建议**：推荐采用“离源构建”方式，在根目录外创建build目录，避免编译产物污染源码目录，基础构建命令如下：
        `# 1. 创建并进入构建目录
mkdir -p build && cd build
# 2. 执行CMake配置（指定根目录路径）
cmake ..
# 3. 编译项目（-j指定并行编译线程数，提升效率）
` `make -j$(nproc)`

# 五、命名规范

- **一、变量命名**

    - 1.1 局部变量规则：采用全小写蛇形命名，名称需直观反映变量用途，避免无意义的单字母（如a、b，循环计数器除外）。循环计数器推荐使用`i、j、k`等通用标识，多层循环需通过命名区分（如`row_idx、col_idx`）。示例：`user_name、data_buffer、temp_value、row_idx`（通常情况下循环不会超过两层）

    - 1.2 类/结构体成员变量规则：public和protected成员直接使用蛇形命名；private成员在蛇形命名前加`_`前缀，区分访问权限。示例：

    - `public: user_id; protected: _role_type; private: _password_hash`

    

- **二、函数命名**

    - 2.1 普通函数规则：采用全小写蛇形命名，以动词开头明确功能（如get、set、calc、init），参数含义需融入函数名，避免歧义。示例：`get_user_info、calc_total_price、init_network_module`

    - 2.2 类成员函数规则：遵循普通函数命名规则，结合类的职责体现关联性；getter/setter函数以成员变量名命名（如成员`_age`对应`age()`和`age(int)`）。示例：`class User { public: auto age() const -> int; auto age(int new_age) -> ` `int` `; }`;setter应当返回修改后的值

    - 2.3 虚函数与纯虚函数规则：虚函数遵循普通成员函数命名；纯虚函数体现接口特性，以`do_`开头。示例：`virtual auto update() -> void; virtual auto do_process() -> int = 0;`

    - 2.5 函数参数规则：采用全小写蛇形命名，与函数功能匹配，避免使用与调用方变量冲突的名称，可选加`in_/out_/inout_`前缀标识参数方向。示例：`auto transfer_data(const std::span<const char> in_buf, std::span<char> out_buf) -> bool;`

    

- **三、类型命名**

    - 3.1 类与结构体规则：采用全小写蛇形命名，以名词结尾体现实体属性（如`_manager、_handler、_info`），避免使用缩写（通用缩写除外）。示例：`user_manager、data_handler、network_config_info`

    - 3.2 枚举与枚举值规则：必须使用有作用域枚举（enum class）采用蛇形命名；枚举值全大写蛇形命名。示例：`enum class error_type { SUCCESS, FILE_NOT_FOUND, NETWORK_ERROR }; `

    - 3.3 模板参数规则：类型模板参数优先使大驼峰命名（如DataType），简单场景可使用单大写字母（如`T、U`）；非类型模板参数遵循对应变量命名规则。示例：`template <typename data_type, int max_size> class CircularBuffer; template <typename T> auto swap(T& a, T& b) -> void;`

    - 3.4 类型别名（using）规则：使用using而非typedef。与原类型命名风格一致，若为指针/引用别名可加`_ptr/_ref`后缀；容器别名需体现元素类型和容器特性。示例：`using user_ptr = std::unique_ptr<` `u` `ser>; using string_list = std::vector<f::string>;`

- **四、命名空间与模块命名**

    - 4.1 命名空间规则：采用全小写蛇形命名，优先使用嵌套命名空间（`namespace a::b`），层级从项目到模块递减（如项目名→功能模块→子模块）。示例：`namespace f::network::tcp; namespace f::utils::string;`

    - 4.2 C++23模块规则：模块名与对应命名空间保持一致，采用蛇形命名，体现模块核心功能；接口文件（.ixx）名与模块名相同。示例：

    - `export module f` `.` `utils` `.` `json;`对应export namespace f::utils::json{}

- **五、宏定义命名**

    - 禁止使用宏

- **六、文件与目录命名**

    - 6.1 源码文件规则：.cpp/.ixx文件与对应类/模块名一致，蛇形命名。

    - 6.2 目录命名规则：源码目录、模块目录均采用蛇形命名，体现功能分类（如`network、utils`），避免深层嵌套（建议不超过3层）。示例：`modules/network/tcp、src/utils/string`

- **七、命名通用规则**

    - 7.1 可读性要求除通用缩写（id、uuid、json、url、tcp、ip等）外，必须使用单词全称，禁止自创模糊缩写（如用`usr`代替`user`）。

    - 7.2 冲突规避禁止名称隐藏（name shadow），内层作用域实体不得与外层同名；不同模块同名实体需通过命名空间区分。

    - 7.3 一致性要求同类型实体命名风格保持统一。

# 六、初始化规范

- **初始化方式优先**：优先使用大括号初始化（列表初始化）方式，该方式能有效避免窄化转换等问题。若存在歧义（例如，`vector<int>(5)`表示初始化5个默认值为0的int元素，而`vector<int>{5}`表示初始化包含一个值为5的int元素），可根据实际需求选择圆括号初始化。

- **局部变量声明**：局部变量优先采用以下两种声明方式：对于默认初始化对象，使用`auto x = T{}`；对于引用初始化，使用`auto&& x = foo()`。

- **auto强制使用**：局部变量的定义必须使用auto关键字推导类型，减少类型冗余的同时，使代码更简洁灵活，尤其适用于复杂模板类型场景。
- **函数签名**：函数签名必须使用后值类型风格，除非不返回，例如：
```c++
void foo();
auto bar() -> int;
```

# 七、注释规范

注释以“清晰易懂、突出重点”为原则，避免无意义的冗余注释。对于复杂的算法逻辑、核心业务流程或难以直观理解的代码段，必须在其实现之前添加注释，说明代码的功能用途、设计思路、关键参数含义及特殊处理逻辑，便于后续开发与维护人员快速理解。

简单的赋值、循环等基础操作无需额外注释，确保注释与代码同步更新，避免注释与代码脱节导致的误解。

# 八、内存管理规范

- **容器使用要求**：对于C++标准库容器，必须优先使用F模块提供的对应变体（如f::vector替代std::vector），确保内存管理策略与项目整体一致。

- **动态对象所有权管理**：对于具有所有权的动态分配对象，优先使用F模块的`f::make_unique`函数创建实例，并通过`f::unique_ptr`进行生命周期管理，避免手动调用new/delete导致的内存泄漏风险。（除非外部库需要，否则不建议使用std::unique_ptr）

- **无所有权引用管理**：对于无所有权的不可变对象引用，使用左值引用（const T&）进行传递与访问；对于无所有权的可变对象引用，采用指针（T*）管理，明确表示对象可修改且调用者需确保指针有效性。

# 九、封装规范

- **类型命名**：类（class）和结构体（struct）的名称均采用蛇形命名法，与其他实体命名风格保持一致。

- **class与struct选择**：若类型的大部分字段需要对外可读写（数据载体类），优先使用struct；若类型的大部分字段需隐藏（通过成员函数对外提供访问接口），则使用class，明确类型的封装意图。

  - **类成员声明顺序**：类内部成员需严格按照以下顺序声明，确保结构清晰：
  `class my_class{
      // 1. 友元声明
      friend class clazz1;
  ` `    friend auto foo1() noexcept -> void;`

      `
      public:
          // 2. 公有成员函数（按重要程度排序）
          void foo() noexcept;
          auto bar() noexcept -> int&;
          auto operator [](auto&& self, auto i) noexcept -> int&;
    
          // 3. 构造函数、析构函数（按默认->拷贝->移动->带参顺序）
          my_class() noexcept = default;
          my_class(const my_class&) noexcept = default;
          my_class(my_class&&) noexcept = default;
          explicit my_class(int) noexcept;
          ~my_class() noexcept = default;
    
      protected:
          // 4. 保护成员函数与变量
          void foo2() noexcept;
          auto bar2() noexcept -> int;
    
          int
              member1;
    
      private:
          // 5. 私有成员变量
          f::string
              _member2;
      ` `};`

- **成员排版规则**：struct的成员名称需在类型声明的下一行，且与类型左对齐；class的成员名称需在类型声明的下一行，并缩进4个空格，保持代码排版整齐。

- **getter/setter规范**：若因业务需求必须为成员变量设置访问接口（getter/setter），需遵循C++习惯的函数签名风格，示例如下：
`class x{
public:
` `    // getter：返回常量引用` `，视图` `或值，无参数
    auto member() const -> int;
    // setter：接收新值，返回旧值或void
    auto member(int neo_member) -> int;
  
private:
    int
        _member;
};`

- **RAII原则强制**：严格遵循资源获取即初始化（RAII）原则，将资源（内存、文件句柄等）的生命周期与对象绑定。禁止任何形式的二次初始化操作，对象构造完成即表示初始化成功；若初始化过程中发生错误，必须抛出异常（可以考虑f::exception），确保资源不泄露。

# 十、错误处理规范

- **异常类型统一**：对于无法在当前层级处理的错误（如资源分配失败、非法参数等），需使用F模块提供的`f::exception`类型报告错误，该类型支持格式字符串，便于构建清晰的错误信息。

- **可预期错误处理**：对于频繁发生的可预期错误（如可空对象为空、参数校验不通过等），避免使用异常，改用`std::optional`（表示可能不存在的值）或`std::expected`（表示成功结果或错误信息）进行处理，提升性能。

- **错误信息要求**：错误消息需包含足够的上下文信息（如错误发生的位置、相关参数值、错误原因），便于开发人员快速定位与调试问题。如果异常足够复杂，则创建异常类型

# 十一、字面量规范

结构体字面量可以使用指派初始化（designated initializers）方式，增强代码可读性。需严格遵循C++标准规定，按照结构体成员的声明顺序进行指派初始化，禁止乱序指派，示例如下：

```cpp

struct x {
    int a;
    float b;
    const char* c;
};

// 正确：按成员声明顺序指派初始化
auto literal_x = x{
    .a = 1, 
    .b = 2.5f,
    .c = "hello"
};
```

# 十二、测试规范

- **单元测试覆盖**：为项目中的关键功能（如核心算法、工具类、业务逻辑模块）编写单元测试，确保核心功能的正确性与稳定性。

- **接口测试要求**：所有公开对外的接口（包括类的公有成员函数、模块导出函数）都必须配备对应的测试案例，覆盖正常场景、边界场景及异常场景。

- **测试执行规范**：开发过程中需定期（如每次代码提交前、功能开发完成后）运行测试套件，确保新改动不会破坏现有功能，及时发现并修复回归问题。

- **测试文件命名**：测试代码放置于后缀为.test.cpp的源文件中，每一个测试文件都应该有一个自己的main函数

# 十三、字符串处理规范

- **字符串类型统一**：所有字符串处理必须使用F模块提供的`f::string`类型，替代std::string，确保字符串的内存管理、编码处理与项目整体适配。

- **宽窄字符串转换**：宽窄字符串之间的转换，必须使用F模块的`f::cvt`工具函数。该函数第一个参数为输入的(w)string_view，第二个参数为接收转换结果的(w)string引用，示例：`f::cvt(str` `_view` `, ` `w` `str)`。

- **C字符串API适配**：当需要将字符串传递给老式C语言API，且该API的参数为只读时，允许使用const_cast移除f::string对应c_str的const属性（仅限此场景），其他情况禁止使用const_cast破坏常量性。

# 十四、运行时多态规范

- **多态使用原则**：运行时多态（通过虚函数实现）会带来一定的性能开销，使用前需权衡必要性。若多态能显著提升代码的可读性、可扩展性（如实现统一接口的不同子类），则必须使用；若仅为简单逻辑分支，优先使用CRTP（编译期多态）或存储可变状态为数据成员替代。

- **类型判断方式**：运行时需判断对象具体类型时，必须使用f-lib的f::is_instance和f::as，禁止通过自定义标志位等非标准方式判断类型，确保类型判断的安全性与规范性。

# 十五、容器视图规范

- **只读连续视图**：对于连续存储的元素序列（如数组、vector），若仅需只读访问，统一使用`std::span<const T>`作为参数类型，避免拷贝数据，提升性能。

- **可写连续视图**：对于连续存储的元素序列，若需要可写访问，使用`std::span<T>`作为参数类型，明确表示允许修改视图指向的元素。

- **字符串视图**：传递字符串时，若无需修改字符串内容且无需管理字符串生命周期，优先使用`std::string_view`（对应f::string的视图类型），减少字符串拷贝开销。
> （注：文档部分内容可能由 AI 生成）